local lcpp = require("tools/cparser")

local glue = [[
#define __TINYC__
#define static
#define __thread
#define STATIC_ASSERT(x)
//#define ifdef(a,b,...)     ifdef_##a(b,__VA_ARGS__)
//#define ifndef(a,b,...)    ifdef_##a(__VA_ARGS__,b)
//#define ifdef_true(b,...)  b
//#define ifdef_false(b,...) __VA_ARGS__
#define OBJ \
   struct { \
      ifdef(debug, const char *objname;) \
      uintptr_t objheader; \
      array(struct obj*) objchildren; \
   };
#define ENTITY \
   struct { OBJ \
      uintptr_t cflags; \
      void *c[OBJCOMPONENTS_MAX]; \
   };
typedef struct FILE FILE;
typedef long int ptrdiff_t;
typedef long unsigned int size_t;
]]

function trim_multilines(str)
    local lines = str:gmatch("([^\r\n]+)\r?\n?")
    local output = lines()
    for line in lines do
        output = output .. "\n" .. line
    end
    return output
end

io.input("./engine/v4k.h")
local v4k_h = io.read("*all")
v4k_h = v4k_h:gsub("#line", "//#line")

-- Function to read file contents
local function read_file(file_path)
    local file = io.open(file_path, "r")
    if not file then return nil end
    local content = file:read("*all")
    file:close()
    return content
end

-- Function to process #include directives
local function process_includes(content)
    local result = content
    result = result:gsub('#include%s*"([^"]+)"', function(included_file)
        local file_content = read_file("engine/" .. included_file)
        if file_content then
            return file_content
        else
            print("Warning: Could not read file: " .. included_file)
            return ""
        end
    end)
    return result
end

-- Process includes
v4k_h = process_includes(v4k_h)

v4k_h = v4k_h:gsub("#include", "//#include")

print('--autogenerated luajit bindings. do not edit.') -- .. os.date("%Y/%m/%d"))
print('local ffi = require("ffi")')
print('ffi.cdef([[')

local result = lcpp.cppString(glue .. v4k_h, '-', {"-Znopass"}, 'v4k')
--print( trim_multilines(result) )

print(']])')

print([[
local _M = {}
function _M.vec2(x,y)
   local v = ffi.new("union vec2")
   v.x = x
   v.y = y
   return v
end
function _M.vec3(x,y,z)
   local v = ffi.new("union vec3")
   v.x = x
   v.y = y
   v.z = z
   return v
end
function _M.vec4(x,y,z,w)
   local v = ffi.new("union vec4")
   v.x = x
   v.y = y
   v.z = z
   v.w = w
   return v
end
function _M.quat(x,y,z,w)
   local q = ffi.new("union quat")
   v.x = x
   v.y = y
   v.z = z
   v.w = w
   return q
end
function _M.mat44()
   local m = ffi.new("float [16]")
   return m
end

local v4k = ffi.load("v4k")

return setmetatable( _M, {
   __index = function( table, key )
      return v4k[ key ]
   end
} )
]])